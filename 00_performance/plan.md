### 4.0. Базовая механика: latency, throughput, Little, хвосты

Краткое видео / блок (8–10 минут), куда ты:

1. Объединяешь:

    * определения latency / throughput (из throughput-файла)
    * Little’s Law с формулой `Latency = Concurrency / Throughput` и примером с 3000/1000 = 3s (из tail-файла).
2. Объясняешь:

    * почему “среднее время ответа” мусорная метрика;
    * что такое p50/p95/p99/p999;
    * что такое tail latency в одном слайде (без ещё глубокого разборa).
3. Делаешь связку “frustration → деньги” и “чем больше звеньев в цепочке — тем длиннее хвост”.

После этого **во всех остальных блоках ты можешь говорить “как мы обсуждали в начале, latency/throughput связаны…” и не повторять матчасть**.

---

### 4.1. Tail Latency: как не жить на p99

Это первое “боевое” видео — чисто про хвосты.

Берёшь из текущего tail-драфта:

1. Проблему:

    * The Tail at Scale (картинка с цепочкой сервисов и p99, который раздувается).
    * “один затупивший вызов тянет за собой всю цепочку”.
2. Источники хвостов:

    * аппаратные / сетевые / программные (hot key, lock-и, GC, paging, neighbor noisy).
3. Каскад:

    * очереди растут → latency растёт (ссылка на Little, но не переобъясняешь его).
    * ретраи на клиенте / гейтвее / PHP → retry storm.
    * cache-miss avalanche.
    * LB размазывает боль по всем.
4. Техники **против хвоста**:

    * Hedged requests.
    * Tied requests.
    * Request coalescing.
    * Latency-aware load balancing.
    * Deadline propagation.
    * Circuit breaker — но именно в контексте “не даём хвостам убить всё”.
    * Jitter для фоновых задач (чтобы не было thundering herd).
5. Набор метрик:

    * p50/p95/p99/p999.
    * rate of retries.
    * отдельный акцент: “если смотришь только среднее — ты слепой”.
6. Observability:

    * histograms vs summaries.
    * distributed tracing как способ найти, где конкретно лежит хвост.
    * alerting по p99, очередям, ретраям.

Что **я бы отсюда выкинул/перенёс**:

* Priority queues. Это больше про throughput и backpressure.
* Queue-based load leveling. Это почти целиком про сглаживание RPS и throughput, а не чисто про хвост.
* Детальный backpressure — утащить во вторую часть (throughput).

Иначе tail-видео начинает превращаться в “общую производительность” и теряет фокус.

---

### 4.2. Throughput Scaling: почему “добавим серверов” не спасает

Это второе видео, где ты делаешь zoom-out: уже не про единичный пользовательский опыт, а про **масштаб системы и законы роста**. Основной контент — из throughput-файла.

Структура:

1. Краткий рекап:

    * latency vs throughput (одним слайдом, без повторения).
    * Little’s Law — просто напомнил, не выводишь заново.
2. “Почему добавим серверов не работает”:

    * qualitative картинка: рост → плато → деградация.
3. Законы:

    * Amdahl’s Law: непараллелящаяся часть.
    * Gustafson: “увеличили задачу, а не ускорили”.
    * Universal Scalability Law (σ — contention, κ — coherence).
4. Живые примеры:

    * Redis hot key.
    * Postgres sequence / row lock.
    * PHP-FPM max_children и контекстные переключения.
5. Convoy effect / Head-of-Line blocking / Tail amplification / Coordinated omission — как эффекты, убивающие throughput под нагрузкой.
6. **Здесь же** логично держать:

    * backpressure (твоя история с FPM, 429 и “быстрым отказом”).
    * queue-based load leveling.
    * priority queues и разделение воркеров по приоритету.
    * segregation of workloads.
    * изоляция hot keys (L1/L2, отдельные Redis tier’ы).
7. Финал:

    * “Иногда единственный путь вперёд — не добавлять ресурсы, а ломать shared ресурсы, координацию и последовательно выполняющиеся куски”.

И важно: circuit breaker, backpressure и очереди у тебя остаются **в обоих мирах**, но под разным углом:

* в 4.1 — как способ не дать хвостам разнести всё,
* в 4.2 — как способ удержать throughput и не уйти в doom loop при росте нагрузки.

То есть паттерн один, но ментальная модель разная. Это норм.

