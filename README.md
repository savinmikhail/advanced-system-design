# Продвинутый system design

Привет! Меня зовут Михаил, я много лет писал backend на PHP, сейчас занимаюсь менторством.

![Обложка продвинутого system design](weeks_of_coding_save_hours_of_designing.png)
~~на экран~~

В прошлой главе вы разобрали базовую архитектуру: монолит и микросервисы, первые подходы к шардингу и масштабированию.  

В реальном проде, да ещё и под нагрузкой, всплывает 100500 проблем, например:
- среднее время ответа 20 ms, но иногда секунды, и пользователи говорят, что “ничего не работает”;
- рекламная акция дала всего +5% посетителей, а прод от этого лег;
- попытались “ускорить систему”, а в итоге замедлили её и вдобавок поймали плавающие баги.

В этой главе мы последовательно разберём:
- Latency и tail latency — почему среднее время ответа маленькое, а пользователи всё равно страдают.
- Throughput и очереди — как посчитать, какую нагрузку ваша система реально выдержит.
- Шардирование — стратегии, динамическое распределение шардов, cross-shard операции и миграции без простоя.
- Распределённые транзакции между сервисами — 2PC, TCC, саги и как не утонуть в “примерно согласованных” деньгах.
- Многослойное кеширование и когерентность — что делать, когда у вас CDN, Redis, локальный кеш и фича-флаги поверх релизов.
- Трейд-оффы оптимизации — где реально стоит платить за сложность, а где проще добавить железа и жить спокойно.

Задача главы — дать вам язык и инструменты, чтобы обсуждать архитектуру не в стиле “нормально делай — нормально будет”, а в терминах задержек, консистентности и стоимости.

Начнём с базовой механики производительности: latency, tail latency, throughput и очередей.

Потом поверх неё нарастим шардирование, распределённые транзакции и продвинутое кеширование — то, чем вы будете спасать сервис, когда он начнёт тонуть под нагрузкой.
