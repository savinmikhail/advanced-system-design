## Часть 4. Продвинутое кэширование и консистентность кэша

### Блок 4.1. Введение в кеш

В предыдущих главах мы говорили про кэш на уровне "вот Redis, он ускоряет запросы к базе". Это правда, но очень поверхностно.

На практике это ещё и опасное упрощение: неправильно спроектированный кэш легко делает обратное — замедляет сервис или под нагрузкой вообще кладёт систему. И делает это разными, неочевидными способами, к которым мы вернёмся в конце этой части.

При этом часть хвостов (tail latency) и часть cross-shard боли мы как раз пытаемся лечить кэшем:
спрятать медленные запросы, уменьшить fan-out, не ходить каждый раз во все шарды и не считать тяжёлые агрегаты на лету.
Но любой кэш добавляет ещё один слой eventual consistency — данные в нём почти всегда “не совсем как в базе” —
и открывает новые способы выстрелить себе в ногу, если его спроектировать невнимательно.

Для примеров я буду использовать маркетплейс с миллионами товаров, корзинами, заказами — всё как в реальной жизни.

Зачем нужен кэш в продакшене?
Кэш нужен для:
- **Разгрузки БД и внешних API** — вместо 100k запросов в секунду делаем 100 и не DDoS'им систему
- **Ускорения чтений** — карточка товара за 2ms вместо 50ms из БД
- **Переиспользования дорогих вычислений** — рекомендации, агрегаты, отчёты

[//]: # (Когда не нужен кеш?)

Представьте: у вас маркетплейс, на оформление заказа нужно показать актуальный курс валют. Вы интегрировались с внешним сервисом курсов.

**Проблема:** Каждый пользователь при оформлении заказа дёргает этот API. У вас 200 тысяч активных пользователей. Внешний API не ваш, он может упасть, тормозить или банально заблокировать вас за DDoS.

**Решение:** Отдельный воркер раз в минуту запрашивает курсы и кладёт их в Redis. Все запросы пользователей читают из кэша, а не лупят внешний API.

Также кеш может позволить пережить краткосрочное падение бэка/базы - например nginx может отдавать закешированные ответы даже если они устарели при проблемах с upstream через директиву proxy_cache_use_stale

Базовая терминология:
- `cache hit` - попадание в кеш (искомый ключ имелся в кеше)
- `cache miss` — промах в кеше - не нашли искомый элемент
- `hot key` — очень популярный ключ (например, товар дня)
- `stale data` — устаревшие данные в кэше
- `Hit rate` — процент запросов, которые нашли данные в кэше
- `TTL` (Time To Live) — как долго данные живут в кэше
- `Latency` — время ответа из кэша vs из БД

### Кэширование негативных результатов

Техника когда мы можем кешировать например 404 ответы от сторонних апишек, чтобы снизить на них нагрузку. Главное не кешировать это навечно

[//]: # (что не надо кешировать из ошибок - сеть например?)
